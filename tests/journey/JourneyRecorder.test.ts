import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { JourneyRecorder } from '../../src/journey/JourneyRecorder.js';
import { RecordingConfig } from '../../src/types/journey.js';
import { Page } from 'playwright';

// Mock Playwright Page
const mockPage = {
  url: jest.fn(),
  title: jest.fn(),
  screenshot: jest.fn(),
  on: jest.fn(),
  off: jest.fn(),
  evaluate: jest.fn(),
  locator: jest.fn(),
  waitForSelector: jest.fn(),
  addInitScript: jest.fn()
} as unknown as Page;

describe('JourneyRecorder', () => {
  let recorder: JourneyRecorder;
  let config: RecordingConfig;

  beforeEach(() => {
    config = {
      captureScreenshots: true,
      captureNetworkRequests: false,
      ignoredSelectors: ['.loading', '.ads'],
      minimumActionDelay: 100,
      autoGenerateName: true,
      autoGenerateDescription: true,
      smartSelectorGeneration: true
    };

    recorder = new JourneyRecorder(config);

    // Reset all mocks
    jest.clearAllMocks();

    // Setup default mock implementations
    (mockPage.url as jest.Mock).mockReturnValue('https://example.com/test');
    (mockPage.title as jest.Mock).mockReturnValue('Test Page');
    (mockPage.screenshot as jest.Mock).mockResolvedValue(Buffer.from('screenshot'));
    (mockPage.evaluate as jest.Mock).mockResolvedValue({});
  });

  afterEach(async () => {
    if (recorder.isRecording()) {
      await recorder.stopRecording();
    }
  });

  describe('Recording Lifecycle', () => {
    it('should start recording successfully', async () => {
      const journey = await recorder.startRecording(mockPage, {
        urlPattern: 'https://example.com/*',
        requiredElements: []
      });

      expect(recorder.isRecording()).toBe(true);
      expect(journey.startingContext.urlPattern).toBe('https://example.com/*');
      expect(journey.steps).toHaveLength(0);
      expect(mockPage.on).toHaveBeenCalled();
    });

    it('should stop recording and return journey', async () => {
      await recorder.startRecording(mockPage, {
        urlPattern: 'https://example.com/*',
        requiredElements: []
      });

      const journey = await recorder.stopRecording();

      expect(recorder.isRecording()).toBe(false);
      expect(journey).not.toBeNull();
      expect(journey!.id).toBeDefined();
      expect(journey!.createdAt).toBeDefined();
      expect(mockPage.off).toHaveBeenCalled();
    });

    it('should throw error when starting recording twice', async () => {
      await recorder.startRecording(mockPage, {
        urlPattern: 'https://example.com/*',
        requiredElements: []
      });

      await expect(recorder.startRecording(mockPage, {
        urlPattern: 'https://example.com/*',
        requiredElements: []
      })).rejects.toThrow('Recording is already in progress');
    });

    it('should return null when stopping without recording', async () => {
      const journey = await recorder.stopRecording();
      expect(journey).toBeNull();
    });

    it('should pause and resume recording', async () => {
      await recorder.startRecording(mockPage, {
        urlPattern: 'https://example.com/*',
        requiredElements: []
      });

      recorder.pauseRecording();
      expect(recorder.isPaused()).toBe(true);

      recorder.resumeRecording();
      expect(recorder.isPaused()).toBe(false);
    });
  });

  describe('Step Recording', () => {
    beforeEach(async () => {
      await recorder.startRecording(mockPage, {
        urlPattern: 'https://example.com/*',
        requiredElements: []
      });
    });

    it('should record click action', async () => {
      const mockElement = {
        tagName: 'BUTTON',
        textContent: 'Submit',
        getAttribute: jest.fn((attr: string) => {
          if (attr === 'id') return 'submit-btn';
          return null;
        }),
        getBoundingClientRect: () => ({ x: 100, y: 200, width: 80, height: 30 })
      };

      (mockPage.evaluate as jest.Mock).mockResolvedValue({
        tagName: 'BUTTON',
        textContent: 'Submit',
        id: 'submit-btn',
        className: '',
        type: 'button'
      });

      await recorder.recordClick('#submit-btn', mockElement as any);
      const currentJourney = recorder.getCurrentJourney();

      expect(currentJourney?.steps).toHaveLength(1);
      expect(currentJourney?.steps[0]).toMatchObject({
        action: 'click',
        selector: '#submit-btn',
        description: expect.stringContaining('Submit')
      });
    });

    it('should record input fill action', async () => {
      const mockElement = {
        tagName: 'INPUT',
        getAttribute: jest.fn((attr: string) => {
          if (attr === 'id') return 'email';
          if (attr === 'type') return 'email';
          return null;
        }),
        value: 'test@example.com'
      };

      await recorder.recordInput('#email', 'test@example.com', mockElement as any);
      const currentJourney = recorder.getCurrentJourney();

      expect(currentJourney?.steps).toHaveLength(1);
      expect(currentJourney?.steps[0]).toMatchObject({
        action: 'fill',
        selector: '#email',
        value: 'test@example.com'
      });
    });

    it('should record navigation', async () => {
      const newUrl = 'https://example.com/login';
      (mockPage.url as jest.Mock).mockReturnValue(newUrl);

      await recorder.recordNavigation(newUrl);
      const currentJourney = recorder.getCurrentJourney();

      expect(currentJourney?.steps).toHaveLength(1);
      expect(currentJourney?.steps[0]).toMatchObject({
        action: 'navigate',
        url: newUrl
      });
    });

    it('should skip recording when paused', async () => {
      recorder.pauseRecording();

      await recorder.recordClick('#test-btn', {} as any);
      const currentJourney = recorder.getCurrentJourney();

      expect(currentJourney?.steps).toHaveLength(0);
    });

    it('should respect minimum action delay', async () => {
      const startTime = Date.now();

      await recorder.recordClick('#btn1', {} as any);
      await recorder.recordClick('#btn2', {} as any);

      const endTime = Date.now();
      expect(endTime - startTime).toBeGreaterThanOrEqual(config.minimumActionDelay);
    });
  });

  describe('Selector Generation', () => {
    beforeEach(async () => {
      await recorder.startRecording(mockPage, {
        urlPattern: 'https://example.com/*',
        requiredElements: []
      });
    });

    it('should prefer ID selectors', () => {
      const element = {
        id: 'unique-id',
        className: 'some-class',
        tagName: 'DIV'
      } as any;

      const selector = (recorder as any).generateSelector(element);
      expect(selector).toBe('#unique-id');
    });

    it('should use data-testid when available', () => {
      const element = {
        getAttribute: jest.fn((attr: string) => {
          if (attr === 'data-testid') return 'test-element';
          return null;
        }),
        className: 'some-class',
        tagName: 'DIV'
      } as any;

      const selector = (recorder as any).generateSelector(element);
      expect(selector).toBe('[data-testid="test-element"]');
    });

    it('should fallback to class selectors', () => {
      const element = {
        getAttribute: jest.fn(() => null),
        className: 'unique-class',
        tagName: 'SPAN'
      } as any;

      const selector = (recorder as any).generateSelector(element);
      expect(selector).toBe('span.unique-class');
    });

    it('should generate xpath for complex elements', () => {
      const element = {
        getAttribute: jest.fn(() => null),
        className: '',
        tagName: 'DIV',
        textContent: 'Unique Text Content'
      } as any;

      const selector = (recorder as any).generateSelector(element);
      expect(selector).toContain('//div');
    });
  });

  describe('Event Handling', () => {
    it('should emit step events', async () => {
      const stepHandler = jest.fn();
      recorder.on('step', stepHandler);

      await recorder.startRecording(mockPage, {
        urlPattern: 'https://example.com/*',
        requiredElements: []
      });

      await recorder.recordClick('#test-btn', {} as any);

      expect(stepHandler).toHaveBeenCalledWith(
        expect.objectContaining({
          action: 'click',
          selector: '#test-btn'
        })
      );
    });

    it('should emit recording lifecycle events', async () => {
      const startHandler = jest.fn();
      const stopHandler = jest.fn();

      recorder.on('recording-started', startHandler);
      recorder.on('recording-stopped', stopHandler);

      await recorder.startRecording(mockPage, {
        urlPattern: 'https://example.com/*',
        requiredElements: []
      });

      await recorder.stopRecording();

      expect(startHandler).toHaveBeenCalled();
      expect(stopHandler).toHaveBeenCalled();
    });
  });

  describe('Screenshot Capture', () => {
    it('should capture screenshots when enabled', async () => {
      config.captureScreenshots = true;
      recorder = new JourneyRecorder(config);

      await recorder.startRecording(mockPage, {
        urlPattern: 'https://example.com/*',
        requiredElements: []
      });

      await recorder.recordClick('#test-btn', {} as any);

      expect(mockPage.screenshot).toHaveBeenCalled();
    });

    it('should skip screenshots when disabled', async () => {
      config.captureScreenshots = false;
      recorder = new JourneyRecorder(config);

      await recorder.startRecording(mockPage, {
        urlPattern: 'https://example.com/*',
        requiredElements: []
      });

      await recorder.recordClick('#test-btn', {} as any);

      expect(mockPage.screenshot).not.toHaveBeenCalled();
    });
  });

  describe('Journey Metadata', () => {
    it('should auto-generate journey name', async () => {
      (mockPage.title as jest.Mock).mockReturnValue('Login Page');
      (mockPage.url as jest.Mock).mockReturnValue('https://app.example.com/login');

      const journey = await recorder.startRecording(mockPage, {
        urlPattern: 'https://app.example.com/*',
        requiredElements: []
      });

      expect(journey.name).toContain('app.example.com');
    });

    it('should generate description based on actions', async () => {
      await recorder.startRecording(mockPage, {
        urlPattern: 'https://example.com/*',
        requiredElements: []
      });

      await recorder.recordInput('#email', 'test@example.com', {} as any);
      await recorder.recordInput('#password', 'password', {} as any);
      await recorder.recordClick('#login-btn', {} as any);

      const journey = await recorder.stopRecording();
      expect(journey?.description).toContain('3 steps');
    });

    it('should update journey metadata during recording', async () => {
      await recorder.startRecording(mockPage, {
        urlPattern: 'https://example.com/*',
        requiredElements: []
      });

      const initialJourney = recorder.getCurrentJourney();
      const initialTimestamp = initialJourney?.updatedAt;

      await new Promise(resolve => setTimeout(resolve, 50)); // Small delay
      await recorder.recordClick('#test-btn', {} as any);

      const updatedJourney = recorder.getCurrentJourney();
      expect(updatedJourney?.updatedAt).not.toBe(initialTimestamp);
    });
  });

  describe('Error Handling', () => {
    it('should handle page evaluation errors gracefully', async () => {
      (mockPage.evaluate as jest.Mock).mockRejectedValue(new Error('Evaluation failed'));

      await recorder.startRecording(mockPage, {
        urlPattern: 'https://example.com/*',
        requiredElements: []
      });

      // Should not throw
      await expect(recorder.recordClick('#test-btn', {} as any)).resolves.not.toThrow();
    });

    it('should handle screenshot errors gracefully', async () => {
      (mockPage.screenshot as jest.Mock).mockRejectedValue(new Error('Screenshot failed'));

      await recorder.startRecording(mockPage, {
        urlPattern: 'https://example.com/*',
        requiredElements: []
      });

      // Should not throw
      await expect(recorder.recordClick('#test-btn', {} as any)).resolves.not.toThrow();
    });
  });

  describe('Configuration Handling', () => {
    it('should respect ignored selectors', () => {
      const isIgnored = (recorder as any).shouldIgnoreSelector('.loading');
      expect(isIgnored).toBe(true);

      const isNotIgnored = (recorder as any).shouldIgnoreSelector('#important-btn');
      expect(isNotIgnored).toBe(false);
    });

    it('should update configuration', () => {
      const newConfig: RecordingConfig = {
        ...config,
        minimumActionDelay: 200,
        captureScreenshots: false
      };

      recorder.updateConfig(newConfig);

      const currentConfig = recorder.getConfig();
      expect(currentConfig.minimumActionDelay).toBe(200);
      expect(currentConfig.captureScreenshots).toBe(false);
    });
  });
});