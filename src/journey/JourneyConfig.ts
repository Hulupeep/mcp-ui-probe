import os from 'os';
import path from 'path';
import { RecordingConfig, PlaybackConfig, JourneyStorageConfig } from '../types/journey.js';

export interface JourneySystemConfig {
  storage: JourneyStorageConfig;
  recording: RecordingConfig;
  playback: PlaybackConfig;
  ai: {
    openaiApiKey?: string;
    enableAIAnalysis: boolean;
    enableAutoNaming: boolean;
    enableSmartSelectors: boolean;
  };
  features: {
    enableRecording: boolean;
    enablePlayback: boolean;
    enableDiscovery: boolean;
    enableValidation: boolean;
    maxConcurrentJourneys: number;
    enableRealTimeUpdates: boolean;
  };
  performance: {
    cacheSize: number;
    indexUpdateInterval: number;
    cleanupInterval: number;
    maxLogFiles: number;
  };
}

export class JourneyConfigManager {
  private static instance: JourneyConfigManager;
  private config: JourneySystemConfig;

  private constructor() {
    this.config = this.createDefaultConfig();
    this.loadEnvironmentOverrides();
  }

  static getInstance(): JourneyConfigManager {
    if (!JourneyConfigManager.instance) {
      JourneyConfigManager.instance = new JourneyConfigManager();
    }
    return JourneyConfigManager.instance;
  }

  getConfig(): JourneySystemConfig {
    return { ...this.config };
  }

  getStorageConfig(): JourneyStorageConfig {
    return { ...this.config.storage };
  }

  getRecordingConfig(): RecordingConfig {
    return { ...this.config.recording };
  }

  getPlaybackConfig(): PlaybackConfig {
    return { ...this.config.playback };
  }

  updateConfig(updates: Partial<JourneySystemConfig>): void {
    this.config = {
      ...this.config,
      ...updates,
      storage: { ...this.config.storage, ...updates.storage },
      recording: { ...this.config.recording, ...updates.recording },
      playback: { ...this.config.playback, ...updates.playback },
      ai: { ...this.config.ai, ...updates.ai },
      features: { ...this.config.features, ...updates.features },
      performance: { ...this.config.performance, ...updates.performance }
    };
  }

  private createDefaultConfig(): JourneySystemConfig {
    const baseDir = process.env.UI_PROBE_JOURNEY_DIR ||
                   path.join(os.homedir(), '.ui-probe', 'journeys');

    return {
      storage: {
        baseDir,
        collectionsDir: 'collections',
        templatesDir: 'templates',
        backupsDir: 'backups',
        indexFile: 'index.json',
        maxBackups: parseInt(process.env.UI_PROBE_MAX_BACKUPS || '10', 10),
        compressionEnabled: process.env.UI_PROBE_COMPRESSION !== 'false'
      },
      recording: {
        captureScreenshots: process.env.UI_PROBE_SCREENSHOTS !== 'false',
        captureNetworkRequests: process.env.UI_PROBE_NETWORK === 'true',
        ignoredSelectors: this.getIgnoredSelectors(),
        minimumActionDelay: parseInt(process.env.UI_PROBE_MIN_DELAY || '500', 10),
        autoGenerateName: process.env.UI_PROBE_AUTO_NAME !== 'false',
        autoGenerateDescription: process.env.UI_PROBE_AUTO_DESC !== 'false',
        smartSelectorGeneration: process.env.UI_PROBE_SMART_SELECTORS !== 'false'
      },
      playback: {
        speed: parseFloat(process.env.UI_PROBE_PLAYBACK_SPEED || '1.0'),
        pauseOnError: process.env.UI_PROBE_PAUSE_ON_ERROR !== 'false',
        maxRetries: parseInt(process.env.UI_PROBE_MAX_RETRIES || '3', 10),
        screenshotOnFailure: process.env.UI_PROBE_FAILURE_SCREENSHOTS !== 'false',
        continueOnNonCriticalErrors: process.env.UI_PROBE_CONTINUE_ON_ERROR !== 'false',
        validateContext: process.env.UI_PROBE_VALIDATE_CONTEXT !== 'false',
        timeoutMs: parseInt(process.env.UI_PROBE_TIMEOUT || '30000', 10)
      },
      ai: {
        openaiApiKey: process.env.OPENAI_API_KEY,
        enableAIAnalysis: process.env.OPENAI_API_KEY ?
          process.env.UI_PROBE_AI_ANALYSIS !== 'false' : false,
        enableAutoNaming: process.env.OPENAI_API_KEY ?
          process.env.UI_PROBE_AI_NAMING !== 'false' : false,
        enableSmartSelectors: process.env.UI_PROBE_SMART_SELECTORS !== 'false'
      },
      features: {
        enableRecording: process.env.UI_PROBE_DISABLE_RECORDING !== 'true',
        enablePlayback: process.env.UI_PROBE_DISABLE_PLAYBACK !== 'true',
        enableDiscovery: process.env.UI_PROBE_DISABLE_DISCOVERY !== 'true',
        enableValidation: process.env.UI_PROBE_DISABLE_VALIDATION !== 'true',
        maxConcurrentJourneys: parseInt(process.env.UI_PROBE_MAX_CONCURRENT || '5', 10),
        enableRealTimeUpdates: process.env.UI_PROBE_REALTIME !== 'false'
      },
      performance: {
        cacheSize: parseInt(process.env.UI_PROBE_CACHE_SIZE || '100', 10),
        indexUpdateInterval: parseInt(process.env.UI_PROBE_INDEX_INTERVAL || '60000', 10), // 1 minute
        cleanupInterval: parseInt(process.env.UI_PROBE_CLEANUP_INTERVAL || '300000', 10), // 5 minutes
        maxLogFiles: parseInt(process.env.UI_PROBE_MAX_LOGS || '10', 10)
      }
    };
  }

  private loadEnvironmentOverrides(): void {
    // Additional environment-specific overrides can be added here
    if (process.env.NODE_ENV === 'development') {
      this.config.recording.minimumActionDelay = 100; // Faster recording in development
      this.config.playback.speed = 2.0; // Faster playback in development
      this.config.storage.compressionEnabled = false; // Disable compression for easier debugging
    }

    if (process.env.NODE_ENV === 'test') {
      this.config.recording.captureScreenshots = false; // No screenshots in tests
      this.config.playback.timeoutMs = 5000; // Shorter timeouts for tests
      this.config.storage.maxBackups = 2; // Minimal backups for tests
      this.config.ai.enableAIAnalysis = false; // No AI calls in tests
    }

    if (process.env.NODE_ENV === 'production') {
      this.config.performance.cacheSize = 200; // Larger cache in production
      this.config.storage.compressionEnabled = true; // Enable compression to save space
      this.config.features.maxConcurrentJourneys = 10; // Allow more concurrent journeys
    }
  }

  private getIgnoredSelectors(): string[] {
    const defaultIgnored = [
      '.loading',
      '.spinner',
      '.ads',
      '.advertisement',
      '[data-testid*="loading"]',
      '[data-testid*="spinner"]',
      '.cookie-banner',
      '.gdpr-banner',
      '.notification',
      '.toast',
      '.popup',
      '.modal-backdrop',
      '.overlay'
    ];

    const customIgnored = process.env.UI_PROBE_IGNORED_SELECTORS?.split(',') || [];
    return [...defaultIgnored, ...customIgnored];
  }

  // Validation methods
  validateConfig(): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Validate storage config
    if (!this.config.storage.baseDir) {
      errors.push('Storage base directory is required');
    }

    // Validate recording config
    if (this.config.recording.minimumActionDelay < 0) {
      errors.push('Minimum action delay must be non-negative');
    }

    // Validate playback config
    if (this.config.playback.speed <= 0 || this.config.playback.speed > 10) {
      errors.push('Playback speed must be between 0 and 10');
    }

    if (this.config.playback.maxRetries < 0 || this.config.playback.maxRetries > 10) {
      errors.push('Max retries must be between 0 and 10');
    }

    if (this.config.playback.timeoutMs < 1000 || this.config.playback.timeoutMs > 300000) {
      errors.push('Timeout must be between 1000ms and 300000ms');
    }

    // Validate performance config
    if (this.config.performance.cacheSize < 10 || this.config.performance.cacheSize > 1000) {
      errors.push('Cache size must be between 10 and 1000');
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  // Helper methods for common configurations
  configureForTesting(): void {
    this.updateConfig({
      recording: {
        ...this.config.recording,
        captureScreenshots: false,
        minimumActionDelay: 50
      },
      playback: {
        ...this.config.playback,
        timeoutMs: 5000,
        maxRetries: 1
      },
      ai: {
        ...this.config.ai,
        enableAIAnalysis: false
      },
      storage: {
        ...this.config.storage,
        maxBackups: 1,
        compressionEnabled: false
      }
    });
  }

  configureForProduction(): void {
    this.updateConfig({
      recording: {
        ...this.config.recording,
        captureScreenshots: true,
        minimumActionDelay: 1000
      },
      playback: {
        ...this.config.playback,
        timeoutMs: 45000,
        maxRetries: 5
      },
      storage: {
        ...this.config.storage,
        maxBackups: 20,
        compressionEnabled: true
      },
      performance: {
        ...this.config.performance,
        cacheSize: 500
      }
    });
  }

  configureForDevelopment(): void {
    this.updateConfig({
      recording: {
        ...this.config.recording,
        captureScreenshots: true,
        minimumActionDelay: 200
      },
      playback: {
        ...this.config.playback,
        speed: 1.5,
        continueOnNonCriticalErrors: true
      },
      ai: {
        ...this.config.ai,
        enableAIAnalysis: !!process.env.OPENAI_API_KEY
      },
      features: {
        ...this.config.features,
        enableRealTimeUpdates: true
      }
    });
  }

  // Export/import configuration
  exportConfig(): string {
    return JSON.stringify(this.config, null, 2);
  }

  importConfig(configJson: string): boolean {
    try {
      const imported = JSON.parse(configJson) as Partial<JourneySystemConfig>;
      const validation = this.validateImportedConfig(imported);

      if (validation.valid) {
        this.updateConfig(imported);
        return true;
      } else {
        throw new Error(`Invalid configuration: ${validation.errors.join(', ')}`);
      }
    } catch (error) {
      console.error('Failed to import configuration:', error);
      return false;
    }
  }

  private validateImportedConfig(imported: any): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Basic structure validation
    if (typeof imported !== 'object') {
      errors.push('Configuration must be an object');
      return { valid: false, errors };
    }

    // Validate each section if present
    if (imported.recording && typeof imported.recording.minimumActionDelay === 'number') {
      if (imported.recording.minimumActionDelay < 0) {
        errors.push('Recording minimum action delay must be non-negative');
      }
    }

    if (imported.playback && typeof imported.playback.speed === 'number') {
      if (imported.playback.speed <= 0 || imported.playback.speed > 10) {
        errors.push('Playback speed must be between 0 and 10');
      }
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  // Debugging and monitoring
  getConfigSummary(): {
    storage: { baseDir: string; backups: number };
    recording: { screenshots: boolean; delay: number };
    playback: { speed: number; retries: number };
    ai: { enabled: boolean; hasKey: boolean };
    features: { enabled: string[] };
  } {
    return {
      storage: {
        baseDir: this.config.storage.baseDir,
        backups: this.config.storage.maxBackups
      },
      recording: {
        screenshots: this.config.recording.captureScreenshots,
        delay: this.config.recording.minimumActionDelay
      },
      playback: {
        speed: this.config.playback.speed,
        retries: this.config.playback.maxRetries
      },
      ai: {
        enabled: this.config.ai.enableAIAnalysis,
        hasKey: !!this.config.ai.openaiApiKey
      },
      features: {
        enabled: Object.entries(this.config.features)
          .filter(([_, value]) => value === true)
          .map(([key, _]) => key)
      }
    };
  }

  // Check if a feature is enabled
  isFeatureEnabled(feature: keyof JourneySystemConfig['features']): boolean {
    // @ts-ignore - Type inference issue to be fixed
    return this.config.features[feature];
  }

  // Get AI configuration with safety checks
  getAIConfig(): { enabled: boolean; hasApiKey: boolean; config: JourneySystemConfig['ai'] } {
    return {
      enabled: this.config.ai.enableAIAnalysis,
      hasApiKey: !!this.config.ai.openaiApiKey,
      config: { ...this.config.ai }
    };
  }
}

// Export singleton instance
export const journeyConfig = JourneyConfigManager.getInstance();