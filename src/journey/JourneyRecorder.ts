import { Page } from 'playwright';
import { v4 as uuidv4 } from 'uuid';
import { Journey, JourneyStep, StartingContext, RecordingConfig, JourneyEvent } from '../types/journey.js';
import { JourneyStorage } from './JourneyStorage.js';
import { JourneyAnalyzer } from './JourneyAnalyzer.js';
import logger from '../utils/logger.js';
import { EventEmitter } from 'events';

export class JourneyRecorder extends EventEmitter {
  private isRecording = false;
  private currentJourney: Partial<Journey> | null = null;
  private steps: JourneyStep[] = [];
  private startTime: Date | null = null;
  private page: Page | null = null;
  private config: RecordingConfig;
  private storage: JourneyStorage;
  private analyzer: JourneyAnalyzer;
  private lastActionTime = 0;
  private screenshotCounter = 0;

  constructor(config: RecordingConfig, storage: JourneyStorage, analyzer: JourneyAnalyzer) {
    super();
    this.config = config;
    this.storage = storage;
    this.analyzer = analyzer;
  }

  async startRecording(page: Page, initialContext?: Partial<StartingContext>): Promise<string> {
    if (this.isRecording) {
      throw new Error('Recording is already in progress');
    }

    this.page = page;
    this.isRecording = true;
    this.startTime = new Date();
    this.steps = [];
    this.screenshotCounter = 0;

    const journeyId = `journey_${Date.now()}_${uuidv4().slice(0, 8)}`;

    // Capture initial page state
    const currentUrl = page.url();
    const pageTitle = await page.title();

    // Auto-detect starting context if not provided
    const startingContext = initialContext || await this.detectStartingContext(page);

    this.currentJourney = {
      id: journeyId,
      name: `Journey ${new Date().toISOString()}`, // Temporary name
      description: 'Recording in progress...', // Temporary description
      tags: [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    // @ts-ignore - Type inference issue to be fixed
      startingContext,
      steps: [],
      metadata: {
        author: 'Recording Session',
        version: '1.0.0',
        successRate: 0,
        avgDurationMs: 0,
        usageCount: 0,
        difficulty: 'medium',
        environment: ['desktop'],
        browserCompatibility: ['chromium']
      }
    };

    // Set up event listeners for page interactions
    await this.setupEventListeners(page);

    // Take initial screenshot
    if (this.config.captureScreenshots) {
      await this.captureScreenshot('initial');
    }

    logger.info('Journey recording started', {
      journeyId,
      url: currentUrl,
      title: pageTitle
    });

    this.emit('recording_started', { journeyId, url: currentUrl });

    return journeyId;
  }

  async stopRecording(): Promise<Journey> {
    if (!this.isRecording || !this.currentJourney) {
      throw new Error('No active recording');
    }

    this.isRecording = false;
    const endTime = new Date();
    const duration = endTime.getTime() - (this.startTime?.getTime() || 0);

    // Take final screenshot
    if (this.config.captureScreenshots && this.page) {
      await this.captureScreenshot('final');
    }

    // Remove event listeners
    if (this.page) {
      await this.cleanupEventListeners(this.page);
    }

    // Complete the journey object
    const completedJourney: Journey = {
      ...this.currentJourney as any,
      steps: this.steps,
      updatedAt: endTime.toISOString(),
      metadata: {
        ...this.currentJourney.metadata!,
        avgDurationMs: duration
      }
    };

    // Auto-generate name and description if enabled
    if (this.config.autoGenerateName || this.config.autoGenerateDescription) {
      try {
        const analysis = await this.analyzer.analyzeJourney(completedJourney);

        if (this.config.autoGenerateName) {
          completedJourney.name = analysis.suggestedName;
        }

        if (this.config.autoGenerateDescription) {
          completedJourney.description = analysis.suggestedDescription;
        }

        completedJourney.tags = [...completedJourney.tags, ...analysis.suggestedTags];

        if (analysis.suggestedCategory) {
          completedJourney.category = analysis.suggestedCategory;
        }

        completedJourney.metadata.difficulty = analysis.estimatedDifficulty;
      } catch (error) {
        logger.warn('Failed to analyze journey for auto-naming', { error });
      }
    }

    // Save the journey
    await this.storage.saveJourney(completedJourney);

    logger.info('Journey recording completed', {
      journeyId: completedJourney.id,
      name: completedJourney.name,
      steps: this.steps.length,
      duration
    });

    this.emit('recording_completed', {
      journeyId: completedJourney.id,
      journey: completedJourney
    });

    // Clean up
    this.currentJourney = null;
    this.steps = [];
    this.page = null;

    return completedJourney;
  }

  async pauseRecording(): Promise<void> {
    if (!this.isRecording) {
      throw new Error('No active recording to pause');
    }

    // Add a pause step
    await this.recordStep({
      action: 'wait',
      description: 'Recording paused by user',
      waitAfter: 0
    });

    this.emit('recording_paused', { journeyId: this.currentJourney?.id });
    logger.info('Journey recording paused');
  }

  async resumeRecording(): Promise<void> {
    if (!this.isRecording) {
      throw new Error('No active recording to resume');
    }

    // Add a resume step
    await this.recordStep({
      action: 'wait',
      description: 'Recording resumed by user',
      waitAfter: 0
    });

    this.emit('recording_resumed', { journeyId: this.currentJourney?.id });
    logger.info('Journey recording resumed');
  }

  private async setupEventListeners(page: Page): Promise<void> {
    // Listen for navigation events
    page.on('framenavigated', async (frame) => {
      if (frame === page.mainFrame()) {
        await this.recordStep({
          action: 'navigate',
          description: `Navigated to ${frame.url()}`,
          url: frame.url()
        });
      }
    });

    // Set up click event listener
    await page.exposeFunction('__journeyRecorderClick', async (data: any) => {
      await this.handleClickEvent(data);
    });

    // Set up input event listener
    await page.exposeFunction('__journeyRecorderInput', async (data: any) => {
      await this.handleInputEvent(data);
    });

    // Set up form submission listener
    await page.exposeFunction('__journeyRecorderSubmit', async (data: any) => {
      await this.handleSubmitEvent(data);
    });

    // Inject event listeners into the page
    await page.addInitScript(() => {
      // Click events
      document.addEventListener('click', (event) => {
        const target = event.target as HTMLElement;
        if (!target) return;

        const selector = generateSelector(target);
        const data = {
          selector,
          tagName: target.tagName,
          text: target.textContent?.trim() || '',
          className: target.className,
          id: target.id,
          type: target.getAttribute('type'),
          href: target.getAttribute('href'),
          timestamp: new Date().toISOString(),
          url: window.location.href
        };

        (window as any).__journeyRecorderClick?.(data);
      }, true);

      // Input events
      document.addEventListener('input', (event) => {
        const target = event.target as HTMLInputElement;
        if (!target) return;

        const selector = generateSelector(target);
        const data = {
          selector,
          tagName: target.tagName,
          type: target.type,
          name: target.name,
          value: target.type === 'password' ? '[REDACTED]' : target.value,
          placeholder: target.placeholder,
          timestamp: new Date().toISOString(),
          url: window.location.href
        };

        (window as any).__journeyRecorderInput?.(data);
      });

      // Form submission events
      document.addEventListener('submit', (event) => {
        const form = event.target as HTMLFormElement;
        if (!form) return;

        const selector = generateSelector(form);
        const data = {
          selector,
          action: form.action,
          method: form.method,
          timestamp: new Date().toISOString(),
          url: window.location.href
        };

        (window as any).__journeyRecorderSubmit?.(data);
      });

      // Utility function to generate selectors
      function generateSelector(element: HTMLElement): string {
        // Try ID first
        if (element.id) {
          return `#${element.id}`;
        }

        // Try data attributes
        const testId = element.getAttribute('data-testid') || element.getAttribute('data-test');
        if (testId) {
          return `[data-testid="${testId}"]`;
        }

        // Try name attribute for form elements
        if (element.getAttribute('name')) {
          return `[name="${element.getAttribute('name')}"]`;
        }

        // Try class-based selector
        if (element.className && typeof element.className === 'string') {
          const classes = element.className.split(' ').filter(c => c.length > 0 && !c.includes('dynamic'));
          if (classes.length > 0) {
            return `.${classes[0]}`;
          }
        }

        // Try tag + text for buttons and links
        if (['BUTTON', 'A'].includes(element.tagName)) {
          const text = element.textContent?.trim();
          if (text && text.length < 50) {
            return `${element.tagName.toLowerCase()}:has-text("${text}")`;
          }
        }

        // Fallback to tag name with nth-child
        const parent = element.parentElement;
        if (parent) {
          const siblings = Array.from(parent.children).filter(child => child.tagName === element.tagName);
          const index = siblings.indexOf(element) + 1;
          return `${element.tagName.toLowerCase()}:nth-child(${index})`;
        }

        return element.tagName.toLowerCase();
      }
    });
  }

  private async cleanupEventListeners(page: Page): Promise<void> {
    try {
      await page.evaluate(() => {
        // Clean up exposed functions
        delete (window as any).__journeyRecorderClick;
        delete (window as any).__journeyRecorderInput;
        delete (window as any).__journeyRecorderSubmit;
      });
    } catch (error) {
      logger.warn('Failed to cleanup event listeners', { error });
    }
  }

  private async handleClickEvent(data: any): Promise<void> {
    if (!this.shouldRecordAction()) return;

    const description = this.generateClickDescription(data);

    await this.recordStep({
      action: 'click',
      selector: data.selector,
      description,
      metadata: {
        tagName: data.tagName,
        text: data.text,
        className: data.className,
        type: data.type,
        href: data.href
      }
    });
  }

  private async handleInputEvent(data: any): Promise<void> {
    if (!this.shouldRecordAction()) return;

    const description = this.generateInputDescription(data);

    await this.recordStep({
      action: 'fill',
      selector: data.selector,
      value: data.value,
      description,
      metadata: {
        tagName: data.tagName,
        type: data.type,
        name: data.name,
        placeholder: data.placeholder
      }
    });
  }

  private async handleSubmitEvent(data: any): Promise<void> {
    const description = `Submit form: ${data.action || 'current page'}`;

    await this.recordStep({
      action: 'click',
      selector: `${data.selector} [type="submit"], ${data.selector} button[type="submit"]`,
      description,
      metadata: {
        formAction: data.action,
        formMethod: data.method
      }
    });
  }

  private async recordStep(stepData: Partial<JourneyStep>): Promise<void> {
    if (!this.isRecording || !this.page) return;

    const step: JourneyStep = {
      id: `step_${this.steps.length + 1}_${uuidv4().slice(0, 8)}`,
      action: stepData.action || 'click',
      selector: stepData.selector,
      value: stepData.value,
      description: stepData.description || 'User action',
      timestamp: new Date().toISOString(),
      url: this.page.url(),
      waitAfter: stepData.waitAfter || this.config.minimumActionDelay,
      metadata: stepData.metadata
    };

    // Capture screenshot if enabled
    if (this.config.captureScreenshots) {
      step.screenshot = await this.captureScreenshot(`step_${this.steps.length + 1}`);
    }

    this.steps.push(step);
    this.lastActionTime = Date.now();

    logger.debug('Recorded journey step', {
      stepId: step.id,
      action: step.action,
      selector: step.selector,
      description: step.description
    });

    this.emit('step_recorded', {
      type: 'step_recorded',
      journeyId: this.currentJourney?.id,
      stepId: step.id,
      data: step,
      timestamp: step.timestamp
    } as JourneyEvent);
  }

  private shouldRecordAction(): boolean {
    // Skip if action is too soon after the last one
    const timeSinceLastAction = Date.now() - this.lastActionTime;
    return timeSinceLastAction >= this.config.minimumActionDelay;
  }

  private generateClickDescription(data: any): string {
    if (data.tagName === 'BUTTON') {
      return `Click button: ${data.text || 'Unknown button'}`;
    } else if (data.tagName === 'A') {
      return `Click link: ${data.text || data.href || 'Unknown link'}`;
    } else if (data.tagName === 'INPUT' && data.type === 'submit') {
      return `Click submit button: ${data.value || 'Submit'}`;
    } else if (data.text) {
      return `Click element: ${data.text}`;
    } else {
      return `Click ${data.tagName?.toLowerCase() || 'element'}`;
    }
  }

  private generateInputDescription(data: any): string {
    const fieldName = data.name || data.placeholder || 'field';

    if (data.type === 'password') {
      return `Enter password in ${fieldName}`;
    } else if (data.type === 'email') {
      return `Enter email in ${fieldName}`;
    } else if (data.type === 'search') {
      return `Search for: ${data.value}`;
    } else {
      return `Fill ${fieldName} with: ${data.value}`;
    }
  }

  private async captureScreenshot(label: string): Promise<string> {
    if (!this.page || !this.config.captureScreenshots) return '';

    try {
      this.screenshotCounter++;
      const filename = `screenshot_${this.currentJourney?.id}_${this.screenshotCounter}_${label}_${Date.now()}.png`;
      const screenshotPath = `/tmp/claude/${filename}`;

      await this.page.screenshot({
        path: screenshotPath,
        fullPage: false // Only capture viewport for faster recording
      });

      return screenshotPath;
    } catch (error) {
      logger.warn('Failed to capture screenshot', { label, error });
      return '';
    }
  }

  private async detectStartingContext(page: Page): Promise<StartingContext> {
    const currentUrl = page.url();

    // Analyze page elements to determine required elements
    const requiredElements = await page.evaluate(() => {
      const elements = [];

      // Look for forms
      const forms = document.querySelectorAll('form');
      if (forms.length > 0) {
    // @ts-ignore - Type inference issue to be fixed
        elements.push({
          selector: 'form',
          type: 'form' as const,
          description: 'Main form element'
        });
      }

      // Look for login indicators
      const loginElements = document.querySelectorAll('[type="password"], [name*="password"], [id*="password"]');
      if (loginElements.length > 0) {
    // @ts-ignore - Type inference issue to be fixed
        elements.push({
          selector: '[type="password"]',
          type: 'input' as const,
          description: 'Password field indicates login form'
        });
      }

      // Look for important buttons
      const buttons = document.querySelectorAll('button, [role="button"], input[type="submit"]');
      if (buttons.length > 0) {
    // @ts-ignore - Type inference issue to be fixed
        elements.push({
          selector: 'button',
          type: 'button' as const,
          description: 'Interactive buttons'
        });
      }

      return elements;
    });

    // Generate URL pattern
    const urlPattern = currentUrl
      .replace(/\d+/g, '*') // Replace numbers with wildcards
      .replace(/[?&][^=]*=[^&]*/g, '') // Remove query parameters
      .replace(/#.*$/, ''); // Remove hash

    return {
      urlPattern,
      exactUrl: currentUrl,
      requiredElements,
      pageState: {
        // Could be enhanced to detect login state, cart items, etc.
      },
      minContentLength: 100
    };
  }

  // Public getters for status
  get recordingStatus(): { isRecording: boolean; journeyId?: string; stepCount: number } {
    return {
      isRecording: this.isRecording,
      journeyId: this.currentJourney?.id,
      stepCount: this.steps.length
    };
  }

  // Method to manually add custom steps
  async addCustomStep(stepData: Partial<JourneyStep>): Promise<void> {
    if (!this.isRecording) {
      throw new Error('Cannot add step - no active recording');
    }

    await this.recordStep({
      ...stepData,
      description: stepData.description || 'Custom step'
    });
  }

  // Method to update journey metadata during recording
  updateJourneyMetadata(updates: Partial<Journey>): void {
    if (!this.currentJourney) {
      throw new Error('No active journey to update');
    }

    Object.assign(this.currentJourney, updates);
    this.emit('journey_updated', {
      journeyId: this.currentJourney.id,
      updates
    });
  }
}